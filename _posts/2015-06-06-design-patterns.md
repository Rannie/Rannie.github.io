---
layout: post
title:  "设计模式相关小记"
date:   2015-06-06 15:13:00
categories: iOS

---


#设计模式笔记

今天把之前总结的设计模式笔记翻出来复习下，并发到 Git Page 上来。

##对象相关

###原型模式

场景:

* 需要创建的对象应独立于其类型与创建方式
* 要实例化的类是在运行时决定的
* 不想要与产品层次相对应的工厂层次
* 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。
* 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。

NSCopying copyWithZone:

###工厂方法模式

定义：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到子类。

也称为虚构造器(virtual constructor)

场景:

* 编译时无法准确地预期要创建的对象的类
* 类想让其子类决定在运行时创建什么
* 类有若干辅助类为其子类，而你想返回哪个子类这一信息局部化

NSNumber numberWith*:

###抽象工厂模式

定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

抽象工厂与工厂方法:

| 抽象工厂 | 工厂方法 |
|----------|---------|
|通过对象组合创建抽象产品|通过类继承创建抽象产品|
|创建多系列产品|创建一种产品|
|必须修改父类的接口才能支持新的产品|子类化创建者并重载工厂方法以创建新产品|

软件设计的**黄金法则**： 变动需要抽象。

有的抽象工厂实现为一种类簇的形式。要使用什么子类，客户端无需确切知晓，而是有类工厂方法来决定。具体品牌子类的细节不被客户端的视图所见，而子类实现工厂方法，返回共有接口中定义的定制内容。其他实现类簇的基础类有： NSData, NSArray, NSDictionary, NSString.

###生成器模式

定义：将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。

生成器模式两个重要的角色：Director (指导者) 和 Builder (生成器)

![construct](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060701.jpg)

##接口适配

###适配器模式

定义：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类一起工作。

有时它也称为"包装器"(wrapper)。适配器实现客户端所要的某种接口的行为。同时，它又会连接到另一个具有不同接口与行为的对象。一边是客户端懂得如何使用的目标接口，另一边是客户端一无所知的被适配者，适配器站在两者之间。适配器的主要作用是把被适配者的行为传递给管道另一端的客户端。

两种方式：类的继承（类适配器）与实现协议（对象适配器）

![adaptor](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060702.jpg)

###桥接模式

定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

桥接模式的目的是把抽象层次结构从实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层抽象接口。实现层次结构定义了供抽象层使用的底层接口。实现类的引用被封装于抽象层中的实例中时，桥接就形成了。

场景：

* 不想在抽象与其实现之间形成固定的绑定关系
* 抽象及其实现都应可以通过子类化独立进行扩展
* 对抽象的实现进行修改不应影响客户端代码
* 如果每个实现需要额外的子类以细化抽象，则说明有必要把它们分成两个部分
* 想在带有不同抽象接口的多个对象之间共享一个实现

![bridge](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060703.jpg)

###外观模式

定义：为系统中的一组接口提供一个统一的接口。外观定义一个高层接口，让子系统更易于使用。

场景：

* 子系统正逐渐变得复杂。应用模式的过程中演化出许多类。可以使用外观为这些子系统类提供一个较简单的接口。
* 可以使用外观对子系统进行分层。每个子系统级别有一个外观作为入口点。让它们通过其外观进行通信，可以简化它们的依赖关系。

![](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060704.jpg)


##对象去耦

###中介者模式

定义：用一个对象来封装一系列对象的交互方式。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

场景：

* 对象间的交互虽定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解
* 因为对象引用了许多其他对象并与其通讯，导致对象难以复用
* 想要定制一个分布在多个类中的逻辑或行为，又不想生成太多类

![mediator](http://images.cnitblog.com/blog/362290/201312/09205810-8531bd5513e84c6bbfbcd6fb7d4efd3b.png)


###观察者模式

定义：定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

场景：

* 有两种抽象类型相互依赖。将它们封装在各自的对象中，就可以对它们单独进行改变和复用。
* 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
* 一个对象必须通知其他对象，而它又不需知道其他对象是什么。



###组合模式

定义：将对象组合成树形结构以表示"部分-整体"的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。

场景：

* 想获得对象抽象的树形表示（部分-整体层次结构）
* 想让客户端统一处理组合结构中的所有对象。

组合模式的主要意图是让树形结构中的每个节点具有相同的抽象接口。这样整个结构可作为一个统一的抽象结构使用，而不暴露其内部表示。对每个节点的任何操作，可以通过协议或抽象基类中定义的相同接口来进行。


###迭代器模式

定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示

场景：

* 需要访问组合对象的内容，而又不暴露其内部表示
* 需要通过多种方式遍历组合对象
* 需要提供一个统一接口，用来遍历各种类型的组合对象


内部迭代器与外部迭代器的区别

| 外部迭代器 | 内部迭代器 |
|----------------------|----------------------|
| 客户端需要知道外部迭代器才能使用，但是它为客户提供了更多的控制 | 客户端不需要知道任何外部迭代器，而是通过集合对象的特殊接口，或者一次访问一个元素，或者向集合中的每个元素发送消息 |
| 客户端创建并维护外部迭代器 | 集合对象本身创建并维护它的外部迭代器 |
| 客户端可以使用不同外部迭代器实现多种类型的遍历 | 集合对象可以在不修改客户端代码的情况下，选择不同的外部迭代器|

![iterator](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060705.jpg)


###访问者模式

定义：表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素类的前提下定义作用于这些元素的新操作。

场景：

* 一个复杂的对象结构包括很多其他对象，它们有不同的接口（比如组合体），但是想对这些对象实施一些依赖于其具体类型的操作。
* 需要对一个组合结构中的对象进行很多不相关的操作，但是不想让这些操作"污染"这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。
* 定义复杂结构的类很少作修改，但经常需要向其添加新的操作。

访问者模式是扩展组合结构功能的一种强有力的方式。如果组合结构具有精心设计的基本操作，而且结构将来也不会变更，就可以使用访问者模式，用各种不同用途的访问者，以同样的方式访问这个组合结构。访问者模式用尽可能少的修改，可以把组合结构与其他访问者类中的相关算法分离。

![visitor](https://raw.github.com/Rannie/Rannie.github.io/master/images/2015060706.jpg)


-- EOF --

以上为这篇博客全部内容,欢迎提出建议,个人联系方式详见 [关于](http://rannie.github.io/about)。












