---
layout: post
title:  "OpenGL ES 基础以及 iOS 设备渲染探究优化"
date:   2016-02-22 19:46:00
categories: iOS

---


客户端的开发，无非离不开数据和展示，而展示这个方面，首当其冲的就是视图、动画的渲染，切换等等。而且在用户的使用中，UI 是这个 APP 的门面，无论功能有多强大，体验不好也是无法留住用户的。


### 硬件图像显示的基本原理

![crt](http://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png)

首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。

![display](http://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png)

通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。

在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区（*后面会讲到缓冲区以及帧缓冲区的概念*）的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。

双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：

![frame](http://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg)

为了解决这个问题，GPU 通常有一个机制叫做**垂直同步**（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。

那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。


### OpenGL ES

OpenGL ES 是一种软件技术，上文讲到计算机中 CPU GPU 协同工作完成渲染，在手机端，正是 OpenGL ES 横跨在两个处理器之间，协调两个区域之间的数据交换。

OpenGL ES 为了提升渲染的性能，为两个内存区域间的数据交换定义了 **缓冲区** 的概念 (buffers) 。缓冲区是指 GPU 能够控制和管理的连续 RAM 。程序从 CPU 的内存复制数据到 OpenGL ES 的缓冲区。通过独占缓冲区，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓冲区上，意味着 GPU 使用缓冲区中的数据工作的同事，运行在 CPU 中的程序可以继续执行。

GPU 需要知道内存中的那个位置来存储渲染出来的 2D 图像像素数据，接收渲染结果的缓冲区称为 **帧缓冲区 (frame buffer)** 。渲染指令会在适当的时候替换帧缓冲区中的内容，OpenGL ES 会根据特定平台硬件配置和功能设置数据类型和偏移。通常来说，渲染结果可以存储到任意数量的 frame buffer 中。上面提到的双缓冲的两个缓冲称之为 **前帧缓冲区 (front frame buffer)** 和 **后帧缓冲区 (back frame buffer)** 。

在 OpenGL ES 中，所有的图像都可以由点，线段和三角形构成，所以 OpenGL ES 只渲染这三种图形。在接收到一些顶点数据后，经过**顶点着色器 (vertex shader)** 处理，装配输出给**片元着色器 (fragment shader)** ,再经过一些操作最终输出给帧缓冲区。什么是片元呢？通常在顶点着色器输出几何图形数据后，会进行**光栅化 (rasterizing)** 将这些形状数据转换为帧缓存中的颜色像素，而每一个颜色像素就叫做**片元 (fragment)** 。

下图为整个 OpenGL ES 的绘制管道:



